<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>Type play</title>
    

  </head>
    
  <body>
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boockup Pro - Ultra HD Edition</title>
    <style>
        :root { 
            --accent: #000000; 
            --bg-main: #e6e6e6; 
            --panel-bg: #1f1f1f; 
            --card-bg: transparent; 
            --text-p: #999999; 
            --text-s: #666666; 
            --border: #333333; 
            --gold: #d4af37;
            --radius: 0px; 
            --slider-track: #555555; 
        }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            font-family: -apple-system, "SF Pro Display", "Helvetica Neue", Arial, sans-serif; 
            color: var(--text-p); background: var(--bg-main); overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }
        #app { display: flex; width: 100vw; height: 100vh; }
        main { flex: 1; display: flex; align-items: center; justify-content: center; padding: 30px; position: relative; }
        #canvas-container {
            width: auto; height: 90vh; aspect-ratio: 3 / 4; position: relative;
            background: transparent; border-radius: 0; overflow: hidden;
            cursor: default; box-shadow: none; border: none;
        }
        #canvas-container canvas { display: block; width: 100%; height: 100%; }
aside {
width: 400px; height: 100%; background: var(--panel-bg);
border-left: 1px solid var(--border);
display: flex; flex-direction: column;
z-index: 10; overflow-y: auto; scrollbar-width: none;
}
aside::-webkit-scrollbar { display: none; }
.card {
margin: 0; padding: 12px 14px;
border-bottom: 1px solid var(--border);
background: var(--card-bg);
width: 100%; box-sizing: border-box;
}
.card-title {
font-size: 11px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px;
color: #ffffff; margin-bottom: 8px;
display: flex; justify-content: space-between; align-items: center;
}
.row { display: flex; flex-direction: column; gap: 0px; margin-bottom: 8px; }
.row.inline { display: flex; flex-direction: row; align-items: center; justify-content: space-between; gap: 4px; }
.row-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 8px; }
.row-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px; }
.label-group {
display: flex; justify-content: space-between; align-items: center;
margin-bottom: 3px; height: 18px;
}
label { font-size: 13px; font-weight: 600; color: var(--text-p); white-space: nowrap; }
.val-display {
font-size: 11px; font-family: "SF Mono", monospace;
color: #ffffff; font-weight: 900;
background: transparent; padding: 0; min-width: 24px; text-align: right;
}
.upload-info {
    display: flex; align-items: center; gap: 4px; background: rgba(255,255,255,0.05); 
    padding: 2px 6px; border: 1px solid var(--border); 
    max-width: 110px;
}
.upload-name { 
    font-size: 10px; color: #fff; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; 
    flex: 1;
}
.upload-reset { cursor: pointer; color: var(--text-s); font-weight: bold; margin-left: 2px; }
.mm-container { display: flex; align-items: center; gap: 3px; margin-left: 6px; }
.mm-input {
width: 32px; height: 18px;
background: transparent !important;
border: 1px solid #444 !important;
border-radius: 0px;
color: #ffffff !important;
font-family: "SF Mono", "Consolas", monospace;
font-size: 12px;
font-weight: 900;
text-align: center;
padding: 0;
outline: none !important;
box-shadow: none !important;
transition: none !important;
-webkit-font-smoothing: antialiased;
}
.mm-input:focus {
background: transparent !important;
border: 1px solid #444 !important;
outline: none !important;
}
input[type="range"] {
-webkit-appearance: none; width: 100%; height: 14px; background: transparent; outline: none; margin: 0;
}
input[type="range"]::-webkit-slider-runnable-track {
width: 100%; height: 1px; background: var(--slider-track);
}
input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none; width: 10px; height: 10px;
background: #cccccc; border-radius: 50%; cursor: pointer; border: none; margin-top: -4.5px;
}
input[type="text"], select {
border: 1px solid var(--border); padding: 3px 6px; font-size: 11px;
background: transparent; color: var(--text-p); outline: none; font-weight: 500;
}
select option { background: var(--panel-bg); color: var(--text-p); }
input[type="color"] {
-webkit-appearance: none;
-moz-appearance: none;
appearance: none;
width: 12px; height: 12px; cursor: pointer; background: none; padding: 0;
border: 1px solid rgba(255,255,255,0.2); border-radius: 50% !important;
overflow: hidden; flex-shrink: 0; display: inline-block; vertical-align: middle;
box-sizing: border-box; box-shadow: 0 0 0 1px rgba(0,0,0,0.5); margin: 0 2px;
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; border-radius: 50%; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.upload-icon { width: 10px; height: 10px; flex-shrink: 0; }
.btn-upload {
display: inline-flex; align-items: center; justify-content: center; gap: 4px; padding: 4px 8px;
background: transparent; border: 1px solid var(--border);
font-size: 11px; font-weight: 600; color: var(--text-p); cursor: pointer;
}
.btn-upload:hover { background: rgba(255,255,255,0.1); color: #fff; }
.play-btn {
width: 24px; height: 24px;
display: flex; align-items: center; justify-content: center;
border: none;
background: transparent;
cursor: pointer;
font-size: 14px;
font-weight: bold;
color: var(--text-p);
padding: 0;
transition: color 0.2s;
}
.play-btn:hover { color: #fff; background: transparent; }
.footer { padding: 12px 14px 40px 14px; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid var(--border); }
.export-title { font-size: 11px; font-weight: 800; color: #fff; text-transform: uppercase; letter-spacing: 0.5px; }
.footer-btns { display: flex; gap: 8px; flex-wrap: wrap; }
.btn-primary { flex: 1; padding: 12px; background: #fff; color: #000; border: none; font-size: 11px; font-weight: 700; cursor: pointer; text-transform: uppercase; min-width: 80px; }
.btn-primary:hover { background: #ddd; }
#ctx-menu {
position: fixed; display: none; background: #fff; border: none;
z-index: 10000; width: 150px; overflow: hidden; box-shadow: none;
}
#ctx-menu div {
padding: 10px 12px; font-size: 12px; font-weight: 500; cursor: pointer;
border-bottom: 1px solid #f0f0f0; color: #333;
display: flex; justify-content: space-between; align-items: center;
}
#ctx-menu div:last-child { border-bottom: none; }
#ctx-menu div:hover { background: #000; color: #fff; }
#ctx-menu .copy-label { font-size: 10px; font-weight: 800; opacity: 0.6; }
.icon-btn {
width: 20px; height: 20px; border-radius: 50%; border: 1px solid var(--border);
background: transparent; color: var(--text-p); cursor: pointer;
display: flex; align-items: center; justify-content: center; font-size: 10px;
}
.icon-btn.active { background: #fff; color: #000; border-color: #fff; }
.tag-text-btn { cursor: pointer; color: var(--text-s); }
.tag-text-btn:hover { color: #fff; }
.tag-text-btn.active { color: #fff; font-weight: 900; text-decoration: none; }
#halfCoverPanel {
background: rgba(255,255,255,0.05); padding: 8px; margin-top: 4px; margin-bottom: 4px;
border-left: none; display: none;
}
/* 进度条 overlay */
#progressOverlay {
display: none; position: absolute; bottom: 80px; left: 0; width: 100%;
z-index: 9999; justify-content: center; align-items: center;
pointer-events: none;
}
.progress-content {
display: flex; flex-direction: column; width: 480px;
}
.progress-text-row {
display: flex; justify-content: space-between; align-items: flex-end;
margin-bottom: 8px; color: #ffffff; font-family: "SF Mono", monospace;
font-size: 10px; font-weight: 900;
}
.progress-bar-container {
width: 100%; height: 1px; background: rgba(255,255,255,0.25);
position: relative; overflow: hidden;
}
#progressBar {
width: 0%; height: 100%; background: #ffffff;
transition: none;
}
#progressLabel { letter-spacing: 2px; text-transform: uppercase; }
#progressValue { letter-spacing: 1px; }
.rope-text-toggle { cursor: pointer; font-size: 11px; font-weight: bold; color: var(--text-s); }
.rope-text-toggle.active { color: #fff; }
</style>
</head>
<body>
<svg style="display:none">
    <symbol id="icon-up" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
    </symbol>
    <symbol id="icon-dl" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="7 10 12 15 17 10"></polyline>
        <line x1="12" y1="15" x2="12" y2="3"></line>
    </symbol>
</svg>
<video id="bgVideoElement" loop muted playsinline crossorigin="anonymous" style="display:none;"></video>
<div id="app">
    <main id="main-stage">
        <div id="canvas-container">
            <div id="progressOverlay">
                <div class="progress-content">
                    <div class="progress-text-row">
                        <div id="progressLabel">GENERATING SEAMLESS HD MP4 (17.44S / 4 LOOPS)</div>
                        <div id="progressValue">0%</div>
                    </div>
                    <div class="progress-bar-container"><div id="progressBar"></div></div>
                </div>
            </div>
        </div>
        <div id="ctx-menu">
            <div onclick="copyCanvasImage()">复制高清图片 <span class="copy-label">Copy</span></div>
            <div onclick="downloadCanvasImage()">下载图片文件 <svg width="12" height="12"><use href="#icon-dl"/></svg></div>
        </div>
    </main>
    <aside id="control-panel">
        <div class="card">
            <div class="card-title">
                封面定制 Cover
                <div style="display:flex; align-items:center; gap:8px;">
                    <div style="display:flex; align-items:center; gap:3px;">
                        <span style="font-size:10px; color:var(--text-s); font-weight:normal; text-transform:none;">整体色彩</span>
                        <input type="color" id="allCoverColor" value="#ffffff" oninput="updateAllCovers(this.value)" title="同步封面与封底颜色">
                    </div>
                    <select id="rotMode" onchange="window.requestUpdateBook()" style="height: 20px; font-size: 10px; width: 120px; border-color: var(--border);">
                        <option value="Y" selected>水平旋转 (Y轴)</option>
                        <option value="Z">垂直旋转 (Z轴)</option>
                    </select>
                </div>
            </div>
            <div class="row-grid">
                <div style="display:flex; flex-direction:column; gap:4px;">
                    <label>封面</label>
                    <div style="display:flex; gap:4px; align-items:center;">
                        <input type="color" id="fCoverColor" value="#ffffff" oninput="updateColorUI('fCoverColor', this.value)">
                        <div id="u_front" style="flex:1;"><button class="btn-upload" style="width:100%;" onclick="document.getElementById('fCoverImg').click()"><svg class="upload-icon"><use href="#icon-up"/></svg> 文件</button></div>
                        <div id="info_front" class="upload-info" style="display:none"><span class="upload-name" id="name_front"></span><span class="upload-reset" onclick="resetFile('front')">×</span></div>
                        <input type="file" id="fCoverImg" style="display:none" accept="image/*,video/*,.svg" onchange="handleImageUpload(event, 'front')">
                        <button id="btnHalfCover" class="icon-btn" onclick="toggleHalfCover()" title="小封面/腰封"><span style="font-weight:900; font-size:9px;">½</span></button>
                    </div>
                </div>
                <div style="display:flex; flex-direction:column; gap:4px;">
                    <label>封底</label>
                    <div style="display:flex; gap:4px; align-items:center;">
                        <input type="color" id="bCoverColor" value="#ffffff" oninput="updateColorUI('bCoverColor', this.value)">
                        <div id="u_back" style="flex:1;"><button class="btn-upload" style="width:100%;" onclick="document.getElementById('bCoverImg').click()"><svg class="upload-icon"><use href="#icon-up"/></svg> 文件</button></div>
                        <div id="info_back" class="upload-info" style="display:none"><span class="upload-name" id="name_back"></span><span class="upload-reset" onclick="resetFile('back')">×</span></div>
                        <input type="file" id="bCoverImg" style="display:none" accept="image/*,video/*,.svg" onchange="handleImageUpload(event, 'back')">
                    </div>
                </div>
            </div>
            <div id="halfCoverPanel">
                <div class="row inline">
                    <label>小封面设置</label>
                    <div style="display:flex; gap:4px; align-items:center;">
                        <div id="u_hc"><button class="btn-upload" onclick="document.getElementById('hcCoverImg').click()"><svg class="upload-icon"><use href="#icon-up"/></svg> 上传文件</button></div>
                        <div id="info_hc" class="upload-info" style="display:none"><span class="upload-name" id="name_hc"></span><span class="upload-reset" onclick="resetFile('hc')">×</span></div>
                        <input type="file" id="hcCoverImg" style="display:none" accept="image/*,video/*,.svg" onchange="handleHalfCoverUpload(event)">
                        <input type="color" id="hcColor" value="#cccccc" oninput="updateColorUI('hcColor', this.value)">
                    </div>
                </div>
                <div class="row-grid-3">
                    <div class="row">
                        <div class="label-group"><label>宽度</label><div class="mm-container"><span class="val-display" id="v-hcWidth">50%</span><input type="text" id="mm_hcWidth" class="mm-input" onchange="setSliderFromMM('hcWidth', this.value)"></div></div>
                        <input type="range" id="hcWidth" min="10" max="100" value="50" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                    <div class="row">
                        <div class="label-group"><label>高度</label><div class="mm-container"><span class="val-display" id="v-hcHeight">100%</span><input type="text" id="mm_hcHeight" class="mm-input" onchange="setSliderFromMM('hcHeight', this.value)"></div></div>
                        <input type="range" id="hcHeight" min="10" max="100" value="100" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                    <div class="row">
                        <div class="label-group"><label>对齐</label></div>
                        <select id="hcAlign" onchange="requestUpdateBook()" style="height:18px; padding:0; font-size:10px;">
                            <option value="top">顶部对齐</option>
                            <option value="center" selected>居中</option>
                            <option value="bottom">底部对齐</option>
                        </select>
                    </div>
                </div>
            </div>
            <!-- 实时进度控制区 -->
            <div class="row inline" style="margin-top:8px;">
                <div style="display:flex; align-items:center; gap:8px; width:100%;">
                    <label id="rotLabel" style="width:58px; flex-shrink:0;">实时进度</label>
                    <input type="range" id="rotSpeed" min="0" max="100" step="0.01" value="0" style="flex:1; cursor: pointer;" oninput="updateUIVal(this)">
                    <span class="val-display" id="v-rotSpeed" style="width:40px; text-align:right;">0.00s</span>
                    <button id="playPauseBtn" class="play-btn" onclick="toggleRotation()">❙❙</button>
                </div>
            </div>
            <div class="row inline" style="background: rgba(255,255,255,0.05); padding: 6px 8px; margin-top: 5px; margin-bottom: 5px; border: 1px solid var(--border);">
                <label style="font-weight:700; color:#fff;">纸张选择</label>
                <select id="takeoPreset" onchange="applyTakeoPreset()" style="width: 130px; border-color: var(--border);">
                    <option value="custom">-- 自由调整 --</option>
                    <option value="bordeaux">BORDEAUX (深红绒感)</option>
                    <option value="peacock">PEACOCK (孔雀蓝砂)</option>
                    <option value="ecru">ECRU (原色纤维)</option>
                    <option value="nt_raschel">NT RASCHEL</option>
                    <option value="tant">TANT</option>
                    <option value="pachica">PACHICA</option>
                    <option value="mermaid">MERMAID</option>
                    <option value="satogami">SATOGAMI</option>
                    <option value="re_feel">RESI-FEEL</option>
                </select>
            </div>
            <div class="row" style="margin-top:2px;">
                <div class="label-group"><label>纹理深度</label><span class="val-display" id="v-texStrength">40</span></div>
                <input type="range" id="texStrength" min="0" max="500" value="40" oninput="updateUIVal(this); updateTextureDepthLive(this.value)">
                <input type="hidden" id="fiberDensity" value="60">
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                书籍参数 Dimensions
                <div style="display:flex; gap:8px; align-items:center; font-weight: normal; text-transform: none;">
                    <span style="font-size:10px; color:var(--text-s)">书芯配色</span>
                    <input type="color" id="coreColor" value="#ffffff" oninput="updateColorUI('coreColor', this.value)">
                </div>
            </div>
            <div class="row-grid">
                <div class="row">
                    <div class="label-group"><label>高度</label><div class="mm-container"><span class="val-display" id="v-bookLen">5.8</span><input type="text" id="mm_bookLen" class="mm-input" onchange="setSliderFromMM('bookLen', this.value)"></div></div>
                    <input type="range" id="bookLen" min="3" max="10" step="0.1" value="5.8" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
                <div class="row">
                    <div class="label-group"><label>宽度</label><div class="mm-container"><span class="val-display" id="v-bookWidth">4.0</span><input type="text" id="mm_bookWidth" class="mm-input" onchange="setSliderFromMM('bookWidth', this.value)"></div></div>
                    <input type="range" id="bookWidth" min="2" max="8" step="0.1" value="4.0" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
            </div>
            <div class="row-grid">
                <div class="row">
                    <div class="label-group"><label>厚度</label><div class="mm-container"><span class="val-display" id="v-bookThick">0.2</span><input type="text" id="mm_bookThick" class="mm-input" onchange="setSliderFromMM('bookThick', this.value)"></div></div>
                    <input type="range" id="bookThick" min="0.05" max="1.0" step="0.01" value="0.2" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
                <div class="row">
                    <div class="label-group"><label>书口斜率</label><div class="mm-container"><span class="val-display" id="v-bookSlope">0.00</span><input type="text" id="mm_bookSlope" class="mm-input" onchange="setSliderFromMM('bookSlope', this.value)"></div></div>
                    <input type="range" id="bookSlope" min="0" max="1" step="0.01" value="0.00" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
            </div>
            <div class="row inline">
                <label style="color:#ffffff;">绳子参数 Rope</label>
                <div style="display:flex; gap:12px; align-items:center;">
                    <div style="display:flex; gap:3px; align-items:center;">
                        <span style="font-size:11px; color:var(--text-s)">绳子</span>
                        <input type="color" id="ropeColor" value="#3b82f6" oninput="updateColorUI('ropeColor', this.value)">
                    </div>
                    <div id="ropeToggle" class="rope-text-toggle active" onclick="toggleRope()">ON</div>
                    <div style="display:flex; gap:3px; align-items:center; margin-left:4px;">
                        <span style="font-size:10px; color:var(--text-s)">样式</span>
                        <select id="tailStyle" onchange="requestUpdateBook()" style="font-size: 10px; height: 18px; padding: 0 2px; width: 95px; background: transparent;">
                            <option value="A">简约垂坠 (A)</option>
                            <option value="B">灵动飘逸 (B)</option>
                            <option value="C">艺术横扫 (C)</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="row-grid">
                <div class="row">
                    <div class="label-group"><label>绳长</label><span class="val-display" id="v-ropeLen">65</span></div>
                    <input type="range" id="ropeLen" min="20" max="95" value="65" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
                <div class="row">
                    <div class="label-group"><label>绳粗</label><span class="val-display" id="v-ropeThick">0.03</span></div>
                    <input type="range" id="ropeThick" min="0.01" max="0.2" step="0.01" value="0.03" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
            </div>
            <div class="row-grid">
                <div class="row">
                    <div class="label-group"><label>绳结</label><span class="val-display" id="v-knotPos">8</span></div>
                    <input type="range" id="knotPos" min="0" max="100" value="8" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
                <div class="row">
                    <div class="label-group"><label>绳尾长度</label><span class="val-display" id="v-tailLen">1.4</span></div>
                    <input type="range" id="tailLen" min="0.2" max="3.0" step="0.1" value="1.4" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                标签附件 Tags
                <div style="display:flex; gap:4px; align-items:center; font-weight: 800; font-size: 11px; color: var(--text-s);">
                    <span id="btnLarge" class="tag-text-btn active" onclick="toggleTag('large')">主标签</span>
                    <span style="opacity: 0.3;">|</span>
                    <span id="btnSmall" class="tag-text-btn" onclick="toggleTag('small')">副标签</span>
                </div>
            </div>
            <div id="panelLarge">
                <div class="row-grid">
                    <div class="row">
                        <div class="label-group"><label>宽度</label><span class="val-display" id="v-tagW">42</span></div>
                        <input type="range" id="tagW" min="20" max="130" value="42" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                    <div class="row">
                        <div class="label-group"><label>高度</label><span class="val-display" id="v-tagH">1.8</span></div>
                        <input type="range" id="tagH" min="0.5" max="2.5" step="0.05" value="1.8" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                </div>
                <div class="row-grid">
                    <div class="row">
                        <div class="label-group"><label>位置</label><span class="val-display" id="v-tagPos">75</span></div>
                        <input type="range" id="tagPos" min="0" max="100" value="75" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                    <div class="row">
                        <div class="label-group"><label>整体缩放</label><span class="val-display" id="v-tagScale">100%</span></div>
                        <input type="range" id="tagScale" min="50" max="200" value="100" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                </div>
                <div class="row">
                    <div class="label-group"><label id="lbl_tagFontSize_L">文字大小</label><span class="val-display" id="v-tagFontSize">65</span></div>
                    <input type="range" id="tagFontSize" min="10" max="150" value="65" oninput="updateUIVal(this);requestUpdateBook()">
                </div>
                <div class="row inline"><label>内容与配色</label>
                    <div style="display:flex; gap:4px; align-items:center;">
                        <input type="text" id="tagT_F" value="FRONT" style="width:60px; font-size:10px;" oninput="requestUpdateBook()">
                        <input type="text" id="tagT_B" value="BACK" style="width:60px; font-size:10px;" oninput="requestUpdateBook()">
                        <input type="color" id="tagBG" title="背景色" value="#ffffff" oninput="updateColorUI('tagBG', this.value)">
                        <input type="color" id="tagTC" title="文字色" value="#000000" oninput="updateColorUI('tagTC', this.value)">
                        <div id="u_tagL"><button class="icon-btn" onclick="document.getElementById('tagSvgL').click()" title="上传SVG"><svg class="upload-icon"><use href="#icon-up"/></svg></button></div>
                        <div id="info_tagL" class="upload-info" style="display:none"><span class="upload-name" id="name_tagL"></span><span class="upload-reset" onclick="resetFile('tagL')">×</span></div>
                        <input type="file" id="tagSvgL" style="display:none" accept=".svg" onchange="handleTagSvgUpload(event, 'large')">
                    </div>
                </div>
            </div>
            <div id="panelSmall" style="display:none; margin-top:8px; border-top:1px solid var(--border); padding-top:8px;">
                <div class="row-grid">
                    <div class="row">
                        <div class="label-group"><label>宽度</label><span class="val-display" id="v-sTagW">45</span></div>
                        <input type="range" id="sTagW" min="20" max="130" value="45" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                    <div class="row">
                        <div class="label-group"><label>高度</label><span class="val-display" id="v-sTagH">0.7</span></div>
                        <input type="range" id="sTagH" min="0.3" max="1.5" step="0.1" value="0.7" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                </div>
                <div class="row-grid">
                    <div class="row">
                        <div class="label-group"><label>位置</label><span class="val-display" id="v-sTagPos">25</span></div>
                        <input type="range" id="sTagPos" min="0" max="100" value="25" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                    <div class="row">
                        <div class="label-group"><label>整体缩放</label><span class="val-display" id="v-sTagScale">100%</span></div>
                        <input type="range" id="sTagScale" min="50" max="200" value="100" oninput="updateUIVal(this);requestUpdateBook()">
                    </div>
                </div>
                <div class="row">
                    <div class="label-group"><label id="lbl_sTagFontSize_S">文字大小</label><span class="val-display" id="v-sTagFontSize">34</span></div>
                    <input type="range" id="sTagFontSize" min="10" max="100" value="34" oninput="requestUpdateBook()">
                </div>
                <div class="row inline"><label>内容与配色</label>
                    <div style="display:flex; gap:4px; align-items:center;">
                        <input type="text" id="sTagT_F" value="2024" style="width:60px; font-size:10px;" oninput="requestUpdateBook()">
                        <input type="text" id="sTagT_B" value="NEW" style="width:60px; font-size:10px;" oninput="requestUpdateBook()">
                        <input type="color" id="sTagBG" title="背景色" value="#ffffff" oninput="updateColorUI('sTagBG', this.value)">
                        <input type="color" id="sTagTC" title="文字色" value="#cc0000" oninput="updateColorUI('sTagTC', this.value)">
                        <div id="u_tagS"><button class="icon-btn" onclick="document.getElementById('tagSvgS').click()" title="上传SVG"><svg class="upload-icon"><use href="#icon-up"/></svg></button></div>
                        <div id="info_tagS" class="upload-info" style="display:none"><span class="upload-name" id="name_tagS"></span><span class="upload-reset" onclick="resetFile('tagS')">×</span></div>
                        <input type="file" id="tagSvgS" style="display:none" accept=".svg" onchange="handleTagSvgUpload(event, 'small')">
                    </div>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                阴影调节 Shadows
                <select id="shadowMode" onchange="updateShadowSettings()" style="width: 140px; border-color: var(--border); font-weight: normal; text-transform: none;">
                    <option value="none" selected>无阴影</option>
                    <option value="ground">地面模式 (Ground)</option>
                    <option value="top">俯视模式 (Top View)</option>
                </select>
            </div>
            <div class="row" style="margin-top: 4px;">
                <div class="label-group">
                    <label>投影亮度</label>
                    <span class="val-display" id="v-shadowIntensity">15%</span>
                </div>
                <input type="range" id="shadowIntensity" min="0" max="100" value="15" oninput="updateUIVal(this); updateShadowOpacity();">
            </div>
            <div id="topShadowPosRow" class="row" style="display:none; margin-top: 4px;">
                <div class="row-grid" style="margin-bottom:0px; gap:8px;">
                    <div class="row" style="margin-bottom:0px;">
                        <div class="label-group">
                            <label>投影深度 (Z-Axis)</label>
                            <span class="val-display" id="v-topShadowDepth">0.15</span>
                        </div>
                        <input type="range" id="topShadowDepth" min="0.01" max="1.0" step="0.01" value="0.15" oninput="updateUIVal(this); window.requestUpdateBook()">
                    </div>
                    <div class="row" style="margin-bottom:0px;">
                        <div class="label-group"><label>投影方向</label></div>
                        <select id="topShadowDir" onchange="window.updateShadowSettings(); window.requestUpdateBook()" style="height:18px; padding:0; font-size:10px;">
                            <option value="left" selected>左侧投影 (Left)</option>
                            <option value="right">右侧投影 (Right)</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                背景环境 Back
                <div style="display:flex; gap:8px; align-items:center; font-weight: normal; text-transform: none;">
                    <span style="font-size:10px; color:var(--text-s)">界面背景色</span>
                    <input type="color" id="themeSyncColor" value="#e6e6e6" oninput="syncThemeColor(this.value)">
                </div>
            </div>
            <div class="row inline" style="margin-top: 8px;">
                <label>背景模式</label>
                <div style="display:flex; gap:4px; align-items:center;">
                    <select id="bgMode" onchange="updatePageBg()" style="width: 95px;"> 
                        <option value="solid">单色</option>
                        <option value="grad" selected>双色渐变</option>
                        <option value="grad3">三色渐变</option>
                    </select>
                    <div id="bgColorPickers" style="display:flex; gap:4px; align-items:center;">
                        <input type="color" id="bgC1" value="#e6e6e6" oninput="updateColorUI('bgC1', this.value); updatePageBg()" title="Color 1">
                        <input type="color" id="bgC2" value="#000000" oninput="updateColorUI('bgC2', this.value); updatePageBg()" title="Color 2">
                        <input type="color" id="bgC3" value="#ffffff" oninput="updateColorUI('bgC3', this.value); updatePageBg()" title="Color 3">
                    </div>
                    <div style="width:1px; height:18px; background:var(--border); margin:0 1px;"></div>
                    <div id="u_bgMedia"><button class="btn-upload" onclick="document.getElementById('canvasMediaUpload').click()"><svg class="upload-icon"><use href="#icon-up"/></svg> 上传文件</button></div>
                    <div id="info_bgMedia" class="upload-info" style="display:none"><span class="upload-name" id="name_bgMedia"></span><span class="upload-reset" onclick="resetFile('bgMedia')">×</span></div>
                    <input type="file" id="canvasMediaUpload" style="display:none" accept="image/*,video/*" onchange="handleCanvasMedia(event)">
                </div>
            </div>
            <div id="gradControls" style="display:none; margin-top:8px;">
                <div class="row-grid">
                    <div class="row" style="margin-bottom:0;">
                        <div class="label-group"><label>渐变角度</label><span class="val-display" id="v-bgDeg">180°</span></div>
                        <input type="range" id="bgDeg" min="0" max="360" value="180" oninput="updateUIVal(this);updatePageBg()">
                    </div>
                    <div class="row" style="margin-bottom:0;">
                        <div id="grp_bgPos1_2">
                            <div class="label-group"><label>上色位置</label><span class="val-display" id="v-bgPos1_2">0%</span></div>
                            <input type="range" id="bgPos1_2" min="0" max="100" value="0" oninput="updateUIVal(this);updatePageBg()">
                        </div>
                        <div id="grp_bgPos1" style="display:none;">
                            <div class="label-group"><label>上色位置</label><span class="val-display" id="v-bgPos1">0%</span></div>
                            <input type="range" id="bgPos1" min="0" max="100" value="0" oninput="updateUIVal(this);updatePageBg()">
                        </div>
                    </div>
                </div>
                <div class="row-grid" id="gradTriRow2" style="display:none;">
                    <div class="row" style="margin-bottom:0;">
                        <div class="label-group"><label>中间位置</label><span class="val-display" id="v-bgMid">50%</span></div>
                        <input type="range" id="bgMid" min="0" max="100" value="50" oninput="updateUIVal(this);updatePageBg()">
                    </div>
                    <div class="row" style="margin-bottom:0;">
                        <div class="label-group"><label>下色位置</label><span class="val-display" id="v-bgPos3">100%</span></div>
                        <input type="range" id="bgPos3" min="0" max="100" value="100" oninput="updateUIVal(this);updatePageBg()">
                    </div>
                </div>
            </div>
        </div>
        <div class="footer">
            <div class="export-title">导出文件 Export</div>
            <div class="footer-btns">
                <button class="btn-primary" onclick="startExport()">Download MP4</button>
            </div>
        </div>
    </aside>
</div>
<script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';

let scene, camera, renderer, bookGroup, controls, clock, mainLight;
let frontTex = null, backTex = null;
let showLarge = true, showSmall = false, isRotating = true, showRope = true;
let showHalfCover = false, halfCoverTex = null;
let showShadow = false, showTopShadow = false, groundPlane = null, backPlane = null;
let globalFiberTex = null, ropeNormalTex = null;
let tagSvgImg_L = null, tagSvgImg_S = null;
let textCanvas = document.createElement('canvas');
let textTexture = null;
let bgDirty = true;
const UNIT_TO_MM = 25.0;

// --- 动画逻辑锁定与录制参数 ---
const DURATION = 17.44; 
const LOOPS = 4;
const FPS = 30; 
let virtualTime = 0;
let isExporting = false;
let needsBookUpdate = false;

window.updateAllCovers = (val) => {
    document.getElementById('fCoverColor').value = val;
    document.getElementById('bCoverColor').value = val;
    window.requestUpdateBook();
};

const createContactShadowTex = () => {
    const c = document.createElement('canvas'); c.width = 64; c.height = 1; const ctx = c.getContext('2d');
    const grad = ctx.createLinearGradient(0, 0, 64, 0);
    grad.addColorStop(0, 'rgba(0,0,0,0.65)'); grad.addColorStop(0.3, 'rgba(0,0,0,0.25)');
    grad.addColorStop(0.8, 'rgba(0,0,0,0.05)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad; ctx.fillRect(0,0,64,1);
    const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
};
let contactShadowTex = createContactShadowTex();

function setTexSharp(tex) {
    if(!tex) return;
    const maxAniso = renderer.capabilities.getMaxAnisotropy();
    tex.anisotropy = maxAniso;
    tex.minFilter = THREE.LinearMipmapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.generateMipmaps = true;
    tex.needsUpdate = true;
}

function updateUploadUI(type, filename) {
    const info = document.getElementById(`info_${type}`);
    const btn = document.getElementById(`u_${type}`);
    const name = document.getElementById(`name_${type}`);
    if (filename) {
        name.innerText = filename;
        info.style.display = 'flex';
        btn.style.display = 'none';
    } else {
        info.style.display = 'none';
        btn.style.display = 'flex';
    }
}

window.resetFile = (type) => {
    if (type === 'front') { frontTex = null; document.getElementById('fCoverImg').value = ''; }
    else if (type === 'back') { backTex = null; document.getElementById('bCoverImg').value = ''; }
    else if (type === 'hc') { halfCoverTex = null; document.getElementById('hcCoverImg').value = ''; }
    else if (type === 'tagL') { tagSvgImg_L = null; document.getElementById('tagSvgL').value = ''; }
    else if (type === 'tagS') { tagSvgImg_S = null; document.getElementById('tagSvgS').value = ''; }
    else if (type === 'bgMedia') { scene.background = textTexture; document.getElementById('canvasMediaUpload').value = ''; }
    updateUploadUI(type, null);
    window.requestUpdateBook();
};

window.toggleRotation = () => {
    isRotating = !isRotating;
    const btn = document.getElementById('playPauseBtn');
    const label = document.getElementById('rotLabel');
    if (isRotating) {
        btn.innerText = '❙❙';
        label.innerText = '实时进度';
        controls.enableRotate = false;
    } else {
        btn.innerText = '▶';
        label.innerText = '角度旋转';
        // 暂停时强制回零正面视角
        virtualTime = 0; 
        applyRotationLogic();
        controls.enableRotate = true;
    }
};

// --- 修改点：离线采样技术确保下载速度与预览绝对一致且不卡顿 ---
async function startExport() {
    if (isExporting) return;
    isExporting = true;
    
    // 强制同步状态
    const wasRotating = isRotating;
    isRotating = true;
    controls.enableRotate = false;

    const overlay = document.getElementById('progressOverlay');
    const pBar = document.getElementById('progressBar');
    const pVal = document.getElementById('progressValue');
    overlay.style.display = 'flex';
    
    const exportW = 1440;
    const exportH = 1920;
    renderer.setSize(exportW, exportH, false);
    camera.aspect = 3 / 4;
    camera.updateProjectionMatrix();

    let mimeType = 'video/mp4';
    if (!MediaRecorder.isTypeSupported(mimeType)) {
        mimeType = 'video/webm;codecs=h264';
    }

    const stream = renderer.domElement.captureStream(FPS);
    const recorder = new MediaRecorder(stream, {
        mimeType: mimeType,
        videoBitsPerSecond: 100000000 
    });

    const chunks = [];
    recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
    
    recorder.onstop = () => {
        const blob = new Blob(chunks, { type: mimeType });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `Boockup_Seamless_HD.mp4`;
        link.click();
        
        const container = document.getElementById('canvas-container');
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = 3 / 4;
        camera.updateProjectionMatrix();
        
        overlay.style.display = 'none';
        isExporting = false;
        isRotating = wasRotating;
        if(!isRotating) {
            document.getElementById('playPauseBtn').innerText = '▶';
            document.getElementById('rotLabel').innerText = '角度旋转';
            controls.enableRotate = true;
        }
    };

    recorder.start();
    // 核心采样逻辑：锁定每秒30帧，总帧数严格固定为 17.44 * 30
    const totalFrames = Math.round(DURATION * FPS);
    let currentFrame = 0;

    function renderNextFrame() {
        if (currentFrame >= totalFrames) {
            recorder.stop();
            return;
        }

        // 关键点：virtualTime 不由物理时钟驱动，而是由帧索引驱动
        // 这样生成的视频无论渲染快慢，每一帧对应的角度都是数学上完美的，彻底消除卡顿和不同步
        virtualTime = (currentFrame / totalFrames) * DURATION;
        applyRotationLogic();
        renderer.render(scene, camera);

        const progress = (currentFrame / totalFrames) * 100;
        pBar.style.width = progress + '%';
        pVal.innerText = Math.floor(progress) + '%';

        currentFrame++;
        // 使用 RAF 逐帧渲染并捕捉，确保护保录制流的稳定性
        requestAnimationFrame(renderNextFrame);
    }
    
    renderNextFrame();
}

window.startExport = startExport;

function applyRotationLogic() {
    const rotMode = document.getElementById('rotMode').value;
    const totalAngle = Math.PI * 2 * LOOPS;
    const progress = (virtualTime % DURATION) / DURATION;
    const currentAngle = progress * totalAngle;

    if (rotMode === 'Y') { 
        bookGroup.rotation.y = currentAngle; 
        bookGroup.rotation.z = 0; 
    } else { 
        bookGroup.rotation.z = currentAngle; 
        bookGroup.rotation.y = 0; 
    }

    if (!isExporting) {
        document.getElementById('rotSpeed').value = (progress * 100).toFixed(2);
        document.getElementById('v-rotSpeed').innerText = `${(virtualTime % DURATION).toFixed(2)}s`;
    }
}

function animate() {
    requestAnimationFrame(animate);
    if (!isExporting) {
        const delta = clock.getDelta();
        if (isRotating) {
            virtualTime = (virtualTime + delta) % DURATION;
        }
        applyRotationLogic();
        renderer.render(scene, camera);
    }
    if (controls) controls.update(); 
    if (needsBookUpdate) { window.updateBook(); needsBookUpdate = false; }
    drawMarquee();
}

function drawBackgroundOnCanvas(ctx) {
    const mode = document.getElementById('bgMode').value,
    c1 = document.getElementById('bgC1').value,
    c2 = document.getElementById('bgC2').value,
    c3 = document.getElementById('bgC3').value,
    deg = document.getElementById('bgDeg').value,
    w = textCanvas.width,
    h = textCanvas.height;
    ctx.clearRect(0,0,w,h);
    if(mode === 'solid') { ctx.fillStyle = c1; ctx.fillRect(0, 0, w, h); }
    else {
        const rad = (deg - 90) * Math.PI / 180, hyp = Math.sqrt(w*w + h*h),
        x1 = w/2 - Math.cos(rad) * (hyp/2), y1 = h/2 - Math.sin(rad) * (hyp/2),
        x2 = w/2 + Math.cos(rad) * (hyp/2), y2 = h/2 + Math.sin(rad) * (hyp/2),
        grad = ctx.createLinearGradient(x1, y1, x2, y2);
        if (mode === 'grad3') {
            grad.addColorStop(Math.min(0.99, Math.max(0.01, document.getElementById('bgPos1').value/100)), c1);
            grad.addColorStop(Math.min(0.99, Math.max(0.01, document.getElementById('bgMid').value/100)), c2);
            grad.addColorStop(Math.min(0.99, Math.max(0.01, document.getElementById('bgPos3').value/100)), c3);
        } else {
            grad.addColorStop(Math.min(0.99, Math.max(0.01, document.getElementById('bgPos1_2').value/100)), c1);
            grad.addColorStop(1, c2);
        }
        ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
        const id = ctx.getImageData(0,0,w,h); const d = id.data;
        for(let i=0; i<d.length; i+=4) {
            const noise = (Math.random() - 0.5) * 5.0;
            d[i] += noise; d[i+1] += noise; d[i+2] += noise;
        }
        ctx.putImageData(id, 0, 0);
    }
}

window.requestUpdateBook = () => { needsBookUpdate = true; };

window.updateUIVal = (el) => {
    const vId = `v-${el.id}`; const disp = document.getElementById(vId);
    if(disp) {
        if(el.id==='rotSpeed') { 
            virtualTime = (parseFloat(el.value)/100) * DURATION; 
            applyRotationLogic(); 
        }
        else { disp.innerText = (el.type==='range' && el.step < 1) ? el.value : (el.id.includes('Scale')||el.id.includes('Width')||el.id.includes('Height')) ? el.value+'%' : el.value; }
    }
    syncMMDisplays();
};

window.updateShadowOpacity = () => {
    const val = parseFloat(document.getElementById('shadowIntensity').value)/100;
    if(groundPlane) groundPlane.material.opacity = val;
    if(backPlane) backPlane.material.opacity = val;
};

window.updateShadowSettings = () => {
    const mode = document.getElementById('shadowMode').value;
    const topDir = document.getElementById('topShadowDir').value;
    showShadow = (mode !== 'none'); showTopShadow = (mode === 'top');
    document.getElementById('topShadowPosRow').style.display = showTopShadow ? 'block' : 'none';
    if(groundPlane) groundPlane.visible = (mode === 'ground');
    if(backPlane) {
        backPlane.visible = showTopShadow;
        if(showTopShadow) {
            mainLight.position.set(topDir === 'left' ? 7 : -7, 6, 12);
            backPlane.position.x = topDir === 'left' ? -2.5 : 2.5;
        } else { mainLight.position.set(2, 8, 12); }
    }
    window.requestUpdateBook();
};

window.syncThemeColor = (val) => { document.body.style.background = val; };
window.updateTextureDepthLive = (val) => {
    const s = val/100;
    bookGroup.traverse(obj => { if(obj.isMesh && obj.material && obj.material.normalMap && obj.name !== 'paper_core') { obj.material.normalScale.set(s*1.8, s*1.8); } });
};

window.downloadCanvasImage = () => {
    const offscreenRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    offscreenRenderer.setSize(2160, 2880); offscreenRenderer.render(scene, camera);
    const link = document.createElement('a'); link.download = `BoockupPro_${Date.now()}.png`; link.href = offscreenRenderer.domElement.toDataURL('image/png'); link.click();
};

window.copyCanvasImage = async () => {
    const offscreenRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    offscreenRenderer.setSize(2160, 2880); offscreenRenderer.render(scene, camera);
    offscreenRenderer.domElement.toBlob(async (blob) => { const item = new ClipboardItem({ "image/png": blob }); await navigator.clipboard.write([item]); alert("高清图片已复制到剪贴板"); });
};

window.updateRopeTexture = () => {
    const c = document.createElement('canvas'); c.width = c.height = 128; const x = c.getContext('2d'); x.fillStyle = '#ffffff'; x.fillRect(0,0,128,128); x.strokeStyle = '#aaaaaa'; x.lineWidth = 4; for(let i=0; i<128; i+=16){ x.beginPath(); x.moveTo(i, 0); x.lineTo(i+64, 128); x.stroke(); }
    ropeNormalTex = new THREE.CanvasTexture(c); ropeNormalTex.wrapS = ropeNormalTex.wrapT = THREE.RepeatWrapping; setTexSharp(ropeNormalTex);
};

window.updateFiberTextures = (params = {}) => {
    const { len = 35, thick = 2.0, density = 60, noise = 0.18, spot = 0.85 } = params;
    const canvasW = 1024; const canvas = document.createElement('canvas'); canvas.width = canvas.height = canvasW;
    const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, canvasW, canvasW);
    const count = (density * 900);
    for(let i=0; i < count; i++) {
        ctx.fillStyle = `rgba(0,0,0,${Math.random() * noise})`; ctx.fillRect(Math.random()*canvasW, Math.random()*canvasW, 1.3, 1.3);
        if(Math.random() > spot) { ctx.fillStyle = `rgba(255,255,255,0.1)`; ctx.fillRect(Math.random()*canvasW, Math.random()*canvasW, 1.8, 1.8); }
    }
    const diffuse = new THREE.CanvasTexture(canvas); diffuse.wrapS = diffuse.wrapT = THREE.RepeatWrapping;
    const nCanvas = document.createElement('canvas'); nCanvas.width = nCanvas.height = canvasW; const nCtx = nCanvas.getContext('2d'); nCtx.fillStyle = 'rgb(128, 128, 255)'; nCtx.fillRect(0, 0, canvasW, canvasW);
    for(let i=0; i < count * 0.95; i++) {
        const x = Math.random() * canvasW, y = Math.random() * canvasW, a = Math.random() * Math.PI * 2, l = Math.random() * len + 4;
        const nx = 128 + (Math.random()-0.5)*90, ny = 128 + (Math.random()-0.5)*90;
        nCtx.beginPath(); nCtx.strokeStyle = `rgb(${nx}, ${ny}, 255)`; nCtx.lineWidth = Math.random() * thick + 0.4; nCtx.moveTo(x, y); nCtx.lineTo(x + Math.cos(a)*l, y + Math.sin(a)*l); nCtx.stroke();
    }
    const normal = new THREE.CanvasTexture(nCanvas); normal.wrapS = normal.wrapT = THREE.RepeatWrapping;
    setTexSharp(diffuse); setTexSharp(normal); globalFiberTex = { diffuse, normal };
};

window.updateColorUI = (id, val) => { const picker = document.getElementById(id); if (picker && picker.value !== val) picker.value = val; window.requestUpdateBook(); };

window.toggleTag = (type) => { 
    if(type === 'large') { 
        showLarge = !showLarge; document.getElementById('btnLarge').classList.toggle('active', showLarge); 
        document.getElementById('panelLarge').style.display = showLarge ? 'block' : 'none'; 
    } else { 
        showSmall = !showSmall; document.getElementById('btnSmall').classList.toggle('active', showSmall); 
        document.getElementById('panelSmall').style.display = showSmall ? 'block' : 'none'; 
    } 
    window.requestUpdateBook(); 
};

window.toggleHalfCover = () => { 
    showHalfCover = !showHalfCover; document.getElementById('btnHalfCover').classList.toggle('active', showHalfCover); 
    document.getElementById('halfCoverPanel').style.display = showHalfCover ? 'block' : 'none'; 
    window.requestUpdateBook(); 
};

window.handleHalfCoverUpload = (event) => {
    const file = event.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); updateUploadUI('hc', file.name);
    if(file.type.startsWith('video/')){
        const v = document.createElement('video'); v.src = url; v.loop = true; v.muted = true; v.oncanplaythrough = () => { v.play(); const tex = new THREE.VideoTexture(v); tex.colorSpace = THREE.SRGBColorSpace; tex.flipY = false; setTexSharp(tex); halfCoverTex = tex; window.requestUpdateBook(); };
    } else { new THREE.TextureLoader().load(url, (tex) => { tex.colorSpace = THREE.SRGBColorSpace; tex.flipY = false; setTexSharp(tex); if (tex) { halfCoverTex = tex; window.requestUpdateBook(); } }); }
};

window.handleTagSvgUpload = (event, type) => {
    const file = event.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); updateUploadUI(type==='large'?'tagL':'tagS', file.name);
    const img = new Image(); img.onload = () => { if(type === 'large') tagSvgImg_L = img; else tagSvgImg_S = img; window.requestUpdateBook(); }; img.src = url;
};

window.handleImageUpload = (event, type) => {
    const file = event.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); updateUploadUI(type, file.name);
    if(file.type.startsWith('video/')){
        const v = document.createElement('video'); v.src = url; v.loop = true; v.muted = true; v.oncanplaythrough = () => { v.play(); const tex = new THREE.VideoTexture(v); tex.colorSpace = THREE.SRGBColorSpace; tex.flipY = false; setTexSharp(tex); if (type === 'front') frontTex = tex; else backTex = tex; window.requestUpdateBook(); };
    } else { new THREE.TextureLoader().load(url, (tex) => { tex.colorSpace = THREE.SRGBColorSpace; tex.flipY = false; setTexSharp(tex); if (type === 'front') frontTex = tex; else backTex = tex; window.requestUpdateBook(); }); }
};

window.handleCanvasMedia = (event) => {
    const file = event.target.files[0]; if (!file) return; const url = URL.createObjectURL(file); updateUploadUI('bgMedia', file.name);
    if (file.type.startsWith('video/')) { 
        const v = document.getElementById('bgVideoElement'); v.src = url; v.oncanplaythrough = () => { v.play(); const tex = new THREE.VideoTexture(v); tex.colorSpace = THREE.SRGBColorSpace; scene.background = tex; }; 
    }
    else { new THREE.TextureLoader().load(url, (tex) => { tex.colorSpace = THREE.SRGBColorSpace; renderer.initTexture(tex); scene.background = tex; }); }
};

window.updatePageBg = () => {
    bgDirty = true; if (!textTexture) { textCanvas.width = 1440; textCanvas.height = 1920; textTexture = new THREE.CanvasTexture(textCanvas); textTexture.colorSpace = THREE.SRGBColorSpace; }
    const mediaInput = document.getElementById('canvasMediaUpload'); if (mediaInput.files && mediaInput.files.length > 0) return;
    scene.background = textTexture;
    const mode = document.getElementById('bgMode').value;
    const grad = document.getElementById('gradControls'); grad.style.display = (mode === 'solid') ? 'none' : 'block';
    document.getElementById('bgC1').style.display = 'inline-block';
    document.getElementById('bgC2').style.display = (mode === 'grad' || mode === 'grad3') ? 'inline-block' : 'none';
    document.getElementById('bgC3').style.display = (mode === 'grad3') ? 'inline-block' : 'none';
};

function drawMarquee() { if (!bgDirty) return; const ctx = textCanvas.getContext('2d'); drawBackgroundOnCanvas(ctx); if (textTexture) textTexture.needsUpdate = true; bgDirty = false; }

function init() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene(); clock = new THREE.Clock();
    camera = new THREE.PerspectiveCamera(22, 3/4, 0.1, 1000); camera.position.set(0, 0, 28);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, logarithmicDepthBuffer: true, powerPreference: "high-performance" });
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(container.clientWidth, container.clientHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
    renderer.toneMapping = THREE.NoToneMapping; renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);
    const pmrem = new THREE.PMREMGenerator(renderer); scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.1).texture;
    mainLight = new THREE.DirectionalLight(0xffffff, 1.6);
    mainLight.position.set(2, 8, 12); mainLight.castShadow = true;
    mainLight.shadow.bias = -0.0003; mainLight.shadow.camera.near = 5; mainLight.shadow.camera.far = 25;
    mainLight.shadow.mapSize.set(2048, 2048); scene.add(mainLight);
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    controls = new OrbitControls(camera, renderer.domElement); 
    controls.enableRotate = false;
    controls.enableDamping = true; 
    controls.dampingFactor = 0.08;
    bookGroup = new THREE.Group(); scene.add(bookGroup);
    groundPlane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.15, transparent: true })); groundPlane.rotation.x = -Math.PI / 2; groundPlane.receiveShadow = true; groundPlane.visible = false; scene.add(groundPlane);
    backPlane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.15, transparent: true })); backPlane.receiveShadow = true; backPlane.visible = false; scene.add(backPlane);
    window.updateRopeTexture(); window.updateFiberTextures(); window.updatePageBg(); window.updateBook(); syncMMDisplays(); animate(); setupContextMenu();
    window.addEventListener('resize', () => { renderer.setSize(container.clientWidth, container.clientHeight); camera.aspect = 3/4; camera.updateProjectionMatrix(); });
}

window.applyTakeoPreset = () => {
    const val = document.getElementById('takeoPreset').value;
    const config = {
        'bordeaux': { strength: 340, color: '#7c2d3b', fiber: { len: 8, thick: 6, density: 95, noise: 0.35 } },
        'peacock': { strength: 380, color: '#289ba8', fiber: { len: 5, thick: 2.2, density: 80, noise: 0.2 } },
        'ecru': { strength: 220, color: '#d8d2bc', fiber: { len: 75, thick: 1.2, density: 70, noise: 0.15 } },
        'nt_raschel': { strength: 160, color: '#e6e3d8', fiber: { len: 15, thick: 3.8, density: 75, noise: 0.12 } },
        'tant': { strength: 420, color: '#f3f0e8', fiber: { len: 6, thick: 1.8, density: 30, noise: 0.05 } },
        'pachica': { strength: 95, color: '#ffffff', fiber: { len: 3, thick: 1, density: 98, noise: 0.02 } },
        'mermaid': { strength: 480, color: '#e0e5e8', fiber: { len: 20, thick: 5, density: 40, noise: 0.28 } },
        'satogami': { strength: 280, color: '#d9d2c5', fiber: { len: 35, thick: 1.5, density: 85, noise: 0.22 } },
        're_feel': { strength: 520, color: '#4a403a', fiber: { len: 6, thick: 8, density: 15, noise: 0.45 } },
        'custom': { strength: 40, color: '#ffffff', fiber: {} }
    };
    if (config[val]) {
        const c = config[val];
        document.getElementById('texStrength').value = c.strength;
        updateColorUI('fCoverColor', c.color); updateColorUI('bCoverColor', c.color);
        document.getElementById('v-texStrength').innerText = c.strength;
        window.updateFiberTextures(c.fiber);
        window.requestUpdateBook();
    }
};

window.setSliderFromMM = (id, mmVal) => {
    const slider = document.getElementById(id); let newVal = mmVal / UNIT_TO_MM;
    if (id === 'hcWidth') newVal = (mmVal / (parseFloat(document.getElementById('bookWidth').value)*UNIT_TO_MM)) * 100;
    if (id === 'hcHeight') newVal = (mmVal / (parseFloat(document.getElementById('bookLen').value)*UNIT_TO_MM)) * 100;
    slider.value = newVal; window.updateUIVal(slider); window.requestUpdateBook();
};

window.syncMMDisplays = () => {
    const upd = (sId, mId) => { const val = parseFloat(document.getElementById(sId).value), input = document.getElementById(mId); if(input) input.value = (val * UNIT_TO_MM).toFixed(1); };
    upd('bookLen', 'mm_bookLen'); upd('bookWidth', 'mm_bookWidth'); upd('bookThick', 'mm_bookThick'); upd('bookSlope', 'mm_bookSlope');
    const bW = parseFloat(document.getElementById('bookWidth').value), bL = parseFloat(document.getElementById('bookLen').value);
    const hcW = document.getElementById('mm_hcWidth'); if(hcW) hcW.value = ((parseFloat(document.getElementById('hcWidth').value)/100) * bW * UNIT_TO_MM).toFixed(1);
    const hcH = document.getElementById('mm_hcHeight'); if(hcH) hcH.value = ((parseFloat(document.getElementById('hcHeight').value)/100) * bL * UNIT_TO_MM).toFixed(1);
};

function createCombinedTagCanvas(w, h, tF, tB, bg, tc, fS, svg) {
    const res = 300, sW = w*res, H = h*res, W = sW*2; const cvs = document.createElement('canvas'); cvs.width = W; cvs.height = H; const ctx = cvs.getContext('2d'); ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);
    const dr = (txt, off, isB) => {
        ctx.save(); ctx.translate(off+sW/2, H/2); if (isB) ctx.rotate(Math.PI/2); else ctx.rotate(-Math.PI/2);
        if (svg) { const sc = (fS/100)*8.0, iW = svg.width, iH = svg.height, asp = iW/iH; let dW = (Math.min(sW,H))*sc, dH = dW/asp; ctx.drawImage(svg, -dW/2, -dH/2, dW, dH); }
        else { ctx.fillStyle = tc; ctx.font = `bold ${fS*1.2}px monospace`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(txt, 0, 0); } ctx.restore();
    };
    dr(tF, 0, false); dr(tB, sW, true); const tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace; setTexSharp(tex); return tex;
}

function createTagMesh(w, l, tF, tB, bG, tC, sT, fS, svg) {
    const t = 0.008, r = sT/2+0.001+t/2, totW = w*2 + Math.PI*r, geo = new THREE.BoxGeometry(totW, l, t, 80, 1, 1);
    const atl = createCombinedTagCanvas(w, l, tF, tB, bG, tC, fS, svg), pos = geo.attributes.position, uv = geo.attributes.uv;
    for (let i = 0; i < pos.count; i++) {
        let x = pos.getX(i), z = pos.getZ(i), nX = x+totW/2;
        if (nX <= w) { pos.setX(i, nX); pos.setZ(i, r+(z>0?  t/2  :-t/2)); uv.setXY(i, (nX/w)*0.5, pos.getY(i)/l+0.5); }
        else if (nX <= (w+Math.PI*r)) { let a = ((nX-w)/(Math.PI*r))*Math.PI, cr = r+(z>0?  t/2  :-t/2); pos.setX(i, w+Math.sin(a)*cr); pos.setZ(i, Math.cos(a)*cr); uv.setXY(i, 0.5, pos.getY(i)/l+0.5); }
        else { let bd = nX-w-Math.PI*r; pos.setX(i, w-bd); pos.setZ(i, -r+(z>0?-t/2:  t/2  )); uv.setXY(i, 0.5+(bd/w)*0.5, pos.getY(i)/l+0.5); }
    } geo.translate(-w, 0, 0); geo.computeVertexNormals();
    const mA = new THREE.MeshStandardMaterial({ map: atl, roughness: 0.5, side: THREE.DoubleSide, dithering: true }); return new THREE.Mesh(geo, [mA, mA, mA, mA, mA, mA]);
}

window.toggleRope = () => { showRope = !showRope; const btn = document.getElementById('ropeToggle'); btn.innerText = showRope ? 'ON' : 'OFF'; btn.classList.toggle('active', showRope); window.requestUpdateBook(); };
function setupContextMenu() { const menu = document.getElementById('ctx-menu'), container = document.getElementById('canvas-container'); container.oncontextmenu = (e) => { e.preventDefault(); menu.style.display = 'block'; menu.style.left = e.pageX + 'px'; menu.style.top = e.pageY + 'px'; }; window.onclick = () => menu.style.display = 'none'; }

window.updateBook = function(targetGroup) {
    const mainTarget = targetGroup || bookGroup; if(!mainTarget) return;
    const savedRotY = mainTarget.rotation.y;
    const savedRotZ = mainTarget.rotation.z;
    const tempGroup = new THREE.Group();
    const bh = parseFloat(document.getElementById('bookLen').value), bw = parseFloat(document.getElementById('bookWidth').value);
    const bThick = parseFloat(document.getElementById('bookThick').value) / 2, slope = parseFloat(document.getElementById('bookSlope').value) || 0;

    if(!targetGroup) { 
        if(groundPlane) groundPlane.position.y = -bh/2 - 0.005; 
        if(backPlane) { const shadowUserOffset = parseFloat(document.getElementById('topShadowDepth').value); backPlane.position.z = -bThick - shadowUserOffset; } 
    }

    const sThick = parseFloat(document.getElementById('ropeThick').value), cColor = document.getElementById('coreColor').value, rColor = document.getElementById('ropeColor').value, texS = document.getElementById('texStrength').value/100, spineR = 0.22, globalOffset = -(bw-spineR)/2, midX = -spineR*0.95, curveP = 64;
    const { diffuse: pFD, normal: pFN } = globalFiberTex;

    const createMat = (isFront, tex) => { 
        const colorVal = isFront ? document.getElementById('fCoverColor').value : document.getElementById('bCoverColor').value; 
        const isUserImg = (tex && tex !== pFD);
        return new THREE.MeshStandardMaterial({ color: isUserImg ? '#ffffff' : colorVal, map: tex || pFD, normalMap: pFN, normalScale: new THREE.Vector2(texS * 1.8, texS * 1.8), roughness: 1.0, metalness: 0.0, envMapIntensity: 0, polygonOffset: true, polygonOffsetFactor: -4, dithering: true }); 
    };

    const pCanvas = document.createElement('canvas'); pCanvas.width = 1024; pCanvas.height = 128; const pCtx = pCanvas.getContext('2d'); pCtx.fillStyle = '#ffffff'; pCtx.fillRect(0,0,1024,128); for(let i=0; i<1024; i+=4) { pCtx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.25)' : 'rgba(0,0,0,0.1)'; pCtx.fillRect(i, 0, 1.5, 128); }
    const paperTex = new THREE.CanvasTexture(pCanvas); paperTex.wrapS = paperTex.wrapT = THREE.RepeatWrapping; paperTex.colorSpace = THREE.SRGBColorSpace; setTexSharp(paperTex);

    const mouthX = bw - slope;
    const paperShape = new THREE.Shape()
        .moveTo(mouthX, bThick)
        .lineTo(0.12, bThick)
        .bezierCurveTo(-spineR + 0.05, bThick, -spineR + 0.05, -bThick, 0.12, -bThick)
        .lineTo(bw, -bThick)
        .lineTo(mouthX, bThick);

    const paperGeo = new THREE.ExtrudeGeometry(paperShape, { depth: bh, bevelEnabled: false, curveSegments: 128 }); paperGeo.computeVertexNormals(); paperGeo.translate(globalOffset, 0, -bh/2); paperGeo.rotateX(Math.PI/2);
    const paperMesh = new THREE.Mesh(paperGeo, new THREE.MeshStandardMaterial({ map: paperTex, color: cColor, roughness: 1.0, metalness: 0.0, name: 'paper_core', dithering: true })); paperMesh.castShadow = true; paperMesh.receiveShadow = true; tempGroup.add(paperMesh);

    const t = 0.012, overlap = 0.01;
    const cFS = new THREE.Shape().moveTo(midX,0).bezierCurveTo(midX+0.01,bThick,0.05,bThick,0.1+overlap,bThick).lineTo(mouthX,bThick).lineTo(mouthX,bThick-t).lineTo(0.1+overlap,bThick-t).bezierCurveTo(0.05,bThick-t,midX+0.01,0,midX,0).closePath();
    const cBS = new THREE.Shape().moveTo(midX,0).bezierCurveTo(midX+0.01,-bThick,0.05,-bThick,0.1+overlap,-bThick).lineTo(bw,-bThick).lineTo(bw,-bThick+t).lineTo(0.1+overlap,-bThick+t).bezierCurveTo(0.05,-bThick+t,midX+0.01,0,midX,0).closePath();

    const renderPart = (sh, tex, isFront) => {
        const geo = new THREE.ExtrudeGeometry(sh, { depth: bh, bevelEnabled: true, bevelThickness: 0.008, bevelSize: 0.006, curveSegments: curveP });
        const pos = geo.attributes.position, uvs = geo.attributes.uv, curMidX = midX, maxX = isFront ? mouthX : bw, totalW = Math.abs(maxX - curMidX);
        for(let i=0; i<pos.count; i++) { let u = Math.abs(pos.getX(i)-curMidX)/totalW; if (!isFront) u = 1-u; uvs.setXY(i, u, pos.getZ(i)/bh); }
        if (tex && tex.image) { tex.matrixAutoUpdate = false; const cAsp = totalW/bh; let iW = tex.isVideoTexture?tex.image.videoWidth:tex.image.width, iH = tex.isVideoTexture?tex.image.videoHeight:tex.image.height; const iAsp = (iW||1)/(iH||1); let sx=1, sy=1, tx=0, ty=0; if (iAsp > cAsp) { sx=cAsp/iAsp; tx=(1-sx)/2; } else { sy=iAsp/cAsp; ty=(1-sy)/2; } tex.matrix.setUvTransform(tx, ty, sx, sy, 0, 0, 0); }
        geo.translate(globalOffset, 0, -bh/2); geo.rotateX(Math.PI/2);
        const mesh = new THREE.Mesh(geo, createMat(isFront, tex)); mesh.castShadow = true; mesh.receiveShadow = true; tempGroup.add(mesh);
    };
    renderPart(cFS, frontTex, true); renderPart(cBS, backTex, false);

    if (showHalfCover) {
        const hcH = bh * (parseFloat(document.getElementById('hcHeight').value) / 100), hcA = document.getElementById('hcAlign').value, hcW = bw * (parseFloat(document.getElementById('hcWidth').value) / 100); const hcG = 0.01, hcT = 0.025; let vS = 0; if (hcA === 'top') vS = (bh - hcH) / 2; else if (hcA === 'bottom') vS = -(bh - hcH) / 2;
        const hcS = new THREE.Shape().moveTo(midX, 0).bezierCurveTo(midX + 0.01, bThick + hcG, 0.05, bThick + hcG, 0.1 + overlap, bThick + hcG).lineTo(0.1 + hcW, bThick + hcG).lineTo(0.1 + hcW, bThick + hcG - hcT).lineTo(0.1 + overlap, bThick + hcG - hcT).bezierCurveTo(0.05, bThick + hcG - hcT, midX + 0.01, 0, midX, 0).closePath();
        const hcGeo = new THREE.ExtrudeGeometry(hcS, { depth: hcH, bevelEnabled: true, bevelThickness: 0.008, bevelSize: 0.006, curveSegments: curveP });
        const pos = hcGeo.attributes.position, uvs = hcGeo.attributes.uv, hcBW = 0.1 + hcW - midX; for(let i = 0; i < pos.count; i++) uvs.setXY(i, (pos.getX(i) - midX) / hcBW, pos.getZ(i) / hcH);
        if (halfCoverTex && halfCoverTex.image) { halfCoverTex.matrixAutoUpdate = false; const bAsp = hcBW / hcH; let iW = halfCoverTex.isVideoTexture ? halfCoverTex.image.videoWidth : halfCoverTex.image.width, iH = halfCoverTex.isVideoTexture ? halfCoverTex.image.videoHeight : halfCoverTex.image.height; const iAsp = (iW || 1) / (iH || 1); let sx = 1, sy = 1, tx = 0, ty = 0; if (iAsp > bAsp) { sx = bAsp / iAsp; tx = (1 - sx) / 2; } else { sy = iAsp / bAsp; ty = 0; } halfCoverTex.matrix.setUvTransform(tx, ty, sx, sy, 0, 0, 0); }
        hcGeo.translate(0, 0, -hcH / 2); hcGeo.rotateX(Math.PI / 2); hcGeo.translate(globalOffset, vS, 0); 
        const hcMesh = new THREE.Mesh(hcGeo, createMat(true, halfCoverTex)); if (!halfCoverTex) hcMesh.material.color.set(document.getElementById('hcColor').value); hcMesh.castShadow = true; hcMesh.receiveShadow = true; tempGroup.add(hcMesh);
    }

    if (showRope) {
        const rLP = document.getElementById('ropeLen').value/100, rY = (bh*rLP)/2, cR = 0.08, rM = new THREE.MeshStandardMaterial({ color: rColor, roughness: 0.7, normalMap: ropeNormalTex, normalScale: new THREE.Vector2(4,4), dithering: true }), rEX = globalOffset-spineR*0.85;
        const rX = (midX+globalOffset-sThick/2), path = new THREE.CurvePath(); path.add(new THREE.LineCurve3(new THREE.Vector3(rEX, rY, 0), new THREE.Vector3(rX+cR, rY, 0))); path.add(new THREE.QuadraticBezierCurve3(new THREE.Vector3(rX+cR, rY, 0), new THREE.Vector3(rX, rY, 0), new THREE.Vector3(rX, rY-cR, 0))); path.add(new THREE.LineCurve3(new THREE.Vector3(rX, rY-cR, 0), new THREE.Vector3(rX, -rY+cR, 0))); path.add(new THREE.QuadraticBezierCurve3(new THREE.Vector3(rX, -rY+cR, 0), new THREE.Vector3(rX, -rY, 0), new THREE.Vector3(rX+cR, -rY, 0))); path.add(new THREE.LineCurve3(new THREE.Vector3(rX+cR, -rY, 0), new THREE.Vector3(rEX, -rY, 0)));
        const rMesh = new THREE.Mesh(new THREE.TubeGeometry(path, 64, sThick/2, 12, false), rM); rMesh.castShadow = true; tempGroup.add(rMesh);
        if(showLarge) { const sc = parseFloat(document.getElementById('tagScale').value)/100, tW = (parseFloat(document.getElementById('tagW').value)/100)*sc, tH = parseFloat(document.getElementById('tagH').value)*sc, ty = (-rY+cR+tH/2) + ((rY*2-cR*2)-tH) * parseFloat(document.getElementById('tagPos').value)/100; const tag = createTagMesh(tW, tH, document.getElementById('tagT_F').value, document.getElementById('tagT_B').value, document.getElementById('tagBG').value, document.getElementById('tagTC').value, sThick, parseFloat(document.getElementById('tagFontSize').value), tagSvgImg_L); tag.position.set(rX, ty, 0); tag.castShadow = true; tempGroup.add(tag); }
        if(showSmall) { const sc = parseFloat(document.getElementById('sTagScale').value)/100, sW = (parseFloat(document.getElementById('sTagW').value)/100)*sc, sH = parseFloat(document.getElementById('sTagH').value)*sc, ty = (-rY+cR+sH/2) + ((rY*2-cR*2)-sH) * parseFloat(document.getElementById('sTagPos').value)/100; const tag = createTagMesh(sW, sH, document.getElementById('sTagT_F').value, document.getElementById('sTagT_B').value, document.getElementById('sTagBG').value, document.getElementById('sTagTC').value, sThick, parseFloat(document.getElementById('sTagFontSize').value), tagSvgImg_S); tag.position.set(rX, ty, 0); tag.castShadow = true; tempGroup.add(tag); }
        const knotY = -rY+cR + (rY*2-cR*2)*(1.0-document.getElementById('knotPos').value/100), tailL = parseFloat(document.getElementById('tailLen').value), knot = new THREE.Mesh(new THREE.CapsuleGeometry(sThick/2*1.8, sThick/2*1.6, 6, 8), rM); knot.position.set(rX, knotY, 0); knot.rotation.z = Math.PI/2.5; knot.castShadow = true; tempGroup.add(knot);
        const genTail = (isL, l) => { const p0 = new THREE.Vector3(rX, knotY, 0); let style = document.getElementById('tailStyle').value, cur; if(style==='A') cur = new THREE.CubicBezierCurve3(p0, new THREE.Vector3(rX-0.15, knotY+0.05, 0.05), new THREE.Vector3(rX-0.35, knotY-0.1, 0.1), new THREE.Vector3(rX + (isL?-0.5:-0.3), knotY - l, 0.12)); else if(style==='B') cur = new THREE.CubicBezierCurve3(p0, isL ? new THREE.Vector3(rX-0.6, knotY+0.6, 0.05) : new THREE.Vector3(rX-0.5, knotY+0.2, 0.05), isL ? new THREE.Vector3(rX-1.6, knotY+0.2, 0.1) : new THREE.Vector3(rX-1.2, knotY-0.4, 0.1), isL ? new THREE.Vector3(rX-1.8, knotY - l*0.8, 0.15) : new THREE.Vector3(rX-1.5, knotY - l*1.2, 0.12)); else cur = new THREE.CubicBezierCurve3(p0, new THREE.Vector3(rX-0.5, knotY+(isL?0.2:-0.1), 0.05), new THREE.Vector3(rX-0.8, knotY-(isL?0.5:0.2), 0.1), new THREE.Vector3(rX-1.1, knotY-(isL?l*1.1:l*0.45), 0.15)); const tM = new THREE.Mesh(new THREE.TubeGeometry(cur, 32, sThick/2*0.8, 8, false), rM); tM.castShadow = true; tempGroup.add(tM); }; genTail(true, tailL); genTail(false, tailL * 0.6);
    }

    while(mainTarget.children.length > 0) { const obj = mainTarget.children[0]; if(obj.geometry) obj.geometry.dispose(); if(obj.material) { if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose()); else obj.material.dispose(); } mainTarget.remove(obj); }
    while(tempGroup.children.length > 0) mainTarget.add(tempGroup.children[0]); 

    mainTarget.rotation.y = savedRotY;
    mainTarget.rotation.z = savedRotZ;
};

init();
</script>
</body>
</html>
    
  </body>
  
</html>
